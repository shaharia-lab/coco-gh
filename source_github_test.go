package cocogh

import (
	"context"
	"testing"

	"github.com/google/go-github/v57/github"
	"github.com/stretchr/testify/mock"
)

// Client is an autogenerated mock type for the Client type
type GHClientMock struct {
	mock.Mock
}

// GetCommit provides a mock function with given fields: ctx, owner, repo, sha, opts
func (_m *GHClientMock) GetCommit(ctx context.Context, owner string, repo string, sha string, opts *github.ListOptions) (*github.RepositoryCommit, *github.Response, error) {
	ret := _m.Called(ctx, owner, repo, sha, opts)

	var r0 *github.RepositoryCommit
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *github.ListOptions) (*github.RepositoryCommit, *github.Response, error)); ok {
		return rf(ctx, owner, repo, sha, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *github.ListOptions) *github.RepositoryCommit); ok {
		r0 = rf(ctx, owner, repo, sha, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RepositoryCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, *github.ListOptions) *github.Response); ok {
		r1 = rf(ctx, owner, repo, sha, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, *github.ListOptions) error); ok {
		r2 = rf(ctx, owner, repo, sha, opts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ListCommits provides a mock function with given fields: ctx, owner, repo, opts
func (_m *GHClientMock) ListCommits(ctx context.Context, owner string, repo string, opts *github.CommitsListOptions) ([]*github.RepositoryCommit, *github.Response, error) {
	ret := _m.Called(ctx, owner, repo, opts)

	var r0 []*github.RepositoryCommit
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *github.CommitsListOptions) ([]*github.RepositoryCommit, *github.Response, error)); ok {
		return rf(ctx, owner, repo, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *github.CommitsListOptions) []*github.RepositoryCommit); ok {
		r0 = rf(ctx, owner, repo, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.RepositoryCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *github.CommitsListOptions) *github.Response); ok {
		r1 = rf(ctx, owner, repo, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, *github.CommitsListOptions) error); ok {
		r2 = rf(ctx, owner, repo, opts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Query provides a mock function with given fields: ctx, q, variables
func (_m *GHClientMock) Query(ctx context.Context, q interface{}, variables map[string]interface{}) error {
	ret := _m.Called(ctx, q, variables)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, map[string]interface{}) error); ok {
		r0 = rf(ctx, q, variables)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

func TestGitHubClient_GetFilePathsForRepositories(t *testing.T) {
	type entry struct {
		Name string
		Path string
		Type string
	}

	tests := []struct {
		name          string
		config        GitHubConfig
		entries       []entry
		expectedFiles []string
	}{
		// Here we specify different test cases. For example:
		{
			name: "test 1",
			config: GitHubConfig{
				Owner:         "testowner1",
				Repositories:  []string{"repo1", "repo2"},
				DefaultBranch: "main1",
				Filter: GitHubFilter{
					FilePath:  "path/to/files",
					FileTypes: []string{".txt"},
				},
			},
			entries: []entry{
				{"File1", "path/to/files/file1.txt", "blob"},
				{"File2", "path/to/files/file2.txt", "blob"},
			},
			expectedFiles: []string{
				"path/to/files/file1.txt",
				"path/to/files/file2.txt",
				"path/to/files/file1.txt",
				"path/to/files/file2.txt",
			},
		},
		// ...more test cases...
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Initialize a mock GitHub client
			ghClient := new(GHClientMock)

			// Create a GitHub client with the mock client and configuration
			client := NewGitHubClient(ghClient, tt.config)

			// Set up the mock to return the query object and populate Entries
			ghClient.On("Query", mock.Anything, mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
				arg := args.Get(1).(*GHQueryForListFiles)

				// Populate Entries here as needed
				for _, entry := range tt.entries {
					arg.Repository.Object.Tree.Entries = append(arg.Repository.Object.Tree.Entries, entry)
				}
			}).Return(nil)

			// Call the method to get file paths for repositories
			files, err := client.GetFilePathsForRepositories()

			// Verify the results
			if err != nil {
				t.Errorf("Error occurred: %v", err)
			}

			for _, expectedFile := range tt.expectedFiles {
				if !contains(files, expectedFile) {
					t.Errorf("Expected file not found: %s", expectedFile)
				}
			}
		})
	}
}

func TestGitHubClient_GetChangedFilePathsSince(t *testing.T) {
	tests := []struct {
		name            string
		config          GitHubConfig
		detectedChanges []*github.CommitFile
		want            Paths
	}{
		{
			name: "Check for changed file paths",
			config: GitHubConfig{
				Owner:         "testowner",
				Repositories:  []string{"repo1", "repo2"},
				DefaultBranch: "main",
				Filter: GitHubFilter{
					FilePath:  "path/to/files",
					FileTypes: []string{".txt"},
				},
			},
			detectedChanges: []*github.CommitFile{
				{
					Filename: github.String("path/to/files/file1.txt"),
					Status:   github.String("added"),
				},
				{
					Filename: github.String("path/to/files/file2.txt"),
					Status:   github.String("modified"),
				},
			},
			want: Paths{
				Added:    []string{"path/to/files/file1.txt", "path/to/files/file1.txt"},
				Removed:  []string{},
				Modified: []string{"path/to/files/file2.txt", "path/to/files/file2.txt"},
			},
		},
		{
			name: "change detected some files with different statuses",
			config: GitHubConfig{
				Owner:         "testowner",
				Repositories:  []string{"repo1"},
				DefaultBranch: "main",
				Filter: GitHubFilter{
					FilePath:  "path/to/files",
					FileTypes: []string{".txt"},
				},
			},
			detectedChanges: []*github.CommitFile{
				{
					Filename: github.String("path/to/files/file_removed.txt"),
					Status:   github.String("removed"),
				},
				{
					Filename: github.String("path/to/files/file_modified.txt"),
					Status:   github.String("modified"),
				},
				{
					Filename: github.String("path/to/files/file_added.txt"),
					Status:   github.String("added"),
				},
				{
					Filename: github.String("path/to/files/file_changed.txt"),
					Status:   github.String("changed"),
				},
				{
					Filename:         github.String("path/to/files/file_renamed.txt"),
					PreviousFilename: github.String("path/to/files/file_previous.txt"),
					Status:           github.String("renamed"),
				},
				{
					Filename: github.String("path/to/files/file_copied.txt"),
					Status:   github.String("copied"),
				},
			},
			want: Paths{
				Added:    []string{"path/to/files/file_added.txt", "path/to/files/file_renamed.txt", "path/to/files/file_copied.txt"},
				Removed:  []string{"path/to/files/file_removed.txt", "path/to/files/file_previous.txt"},
				Modified: []string{"path/to/files/file_modified.txt", "path/to/files/file_changed.txt"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ghClient := new(GHClientMock)
			ghClient.On("ListCommits", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return([]*github.RepositoryCommit{{
				SHA: github.String("1234567890"),
			}}, nil, nil)
			ghClient.On("GetCommit", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(&github.RepositoryCommit{Files: tt.detectedChanges}, nil, nil)

			client := NewGitHubClient(ghClient, tt.config)
			paths, err := client.GetChangedFilePathsSince(1)

			if err != nil {
				t.Errorf("Error occurred: %v", err)
			}

			if !comparePaths(paths, tt.want) {
				t.Errorf("Expected paths do not match the result: %v", paths)
			}
		})
	}
}

// Helper function to check if a string is in a slice
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if s == str {
			return true
		}
	}
	return false
}

// Helper function to compare Paths
func comparePaths(paths1, paths2 Paths) bool {
	return compareStringSlices(paths1.Added, paths2.Added) &&
		compareStringSlices(paths1.Removed, paths2.Removed) &&
		compareStringSlices(paths1.Modified, paths2.Modified)
}

// Helper function to compare string slices
func compareStringSlices(slice1, slice2 []string) bool {
	if len(slice1) != len(slice2) {
		return false
	}
	for i := range slice1 {
		if slice1[i] != slice2[i] {
			return false
		}
	}
	return true
}
