package cocogh

import (
	"context"
	"testing"

	"github.com/google/go-github/v57/github"
	"github.com/stretchr/testify/mock"
)

// GHClient is an autogenerated mock type for the GHClient type
type GHClientMock struct {
	mock.Mock
}

// GetCommit provides a mock function with given fields: ctx, owner, repo, sha, opts
func (_m *GHClientMock) GetCommit(ctx context.Context, owner string, repo string, sha string, opts *github.ListOptions) (*github.RepositoryCommit, *github.Response, error) {
	ret := _m.Called(ctx, owner, repo, sha, opts)

	var r0 *github.RepositoryCommit
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *github.ListOptions) (*github.RepositoryCommit, *github.Response, error)); ok {
		return rf(ctx, owner, repo, sha, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *github.ListOptions) *github.RepositoryCommit); ok {
		r0 = rf(ctx, owner, repo, sha, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RepositoryCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, *github.ListOptions) *github.Response); ok {
		r1 = rf(ctx, owner, repo, sha, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, string, *github.ListOptions) error); ok {
		r2 = rf(ctx, owner, repo, sha, opts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ListCommits provides a mock function with given fields: ctx, owner, repo, opts
func (_m *GHClientMock) ListCommits(ctx context.Context, owner string, repo string, opts *github.CommitsListOptions) ([]*github.RepositoryCommit, *github.Response, error) {
	ret := _m.Called(ctx, owner, repo, opts)

	var r0 []*github.RepositoryCommit
	var r1 *github.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *github.CommitsListOptions) ([]*github.RepositoryCommit, *github.Response, error)); ok {
		return rf(ctx, owner, repo, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *github.CommitsListOptions) []*github.RepositoryCommit); ok {
		r0 = rf(ctx, owner, repo, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.RepositoryCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *github.CommitsListOptions) *github.Response); ok {
		r1 = rf(ctx, owner, repo, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, *github.CommitsListOptions) error); ok {
		r2 = rf(ctx, owner, repo, opts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Query provides a mock function with given fields: ctx, q, variables
func (_m *GHClientMock) Query(ctx context.Context, q interface{}, variables map[string]interface{}) error {
	ret := _m.Called(ctx, q, variables)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, map[string]interface{}) error); ok {
		r0 = rf(ctx, q, variables)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

func TestGitHubClient_GetFilePathsForRepositories(t *testing.T) {
	// Initialize a mock GitHub client
	ghClient := new(GHClientMock)

	// Create a GitHub configuration
	config := GitHubConfig{
		Owner:         "testowner",
		Repositories:  []string{"repo1", "repo2"},
		DefaultBranch: "main",
		Filter: GitHubFilter{
			FilePath:  "path/to/files",
			FileTypes: []string{".txt"},
		},
	}

	// Create a GitHub client with the mock client and configuration
	client := NewGitHubClient(ghClient, config)

	// Create entries and populate them
	entry1 := struct {
		Name string
		Path string
		Type string
	}{
		Name: "File1",
		Path: "path/to/files/file1.txt",
		Type: "blob",
	}

	entry2 := struct {
		Name string
		Path string
		Type string
	}{
		Name: "File2",
		Path: "path/to/files/file2.txt",
		Type: "blob",
	}

	// Set up the mock to return the query object and populate Entries
	ghClient.On("Query", mock.Anything, mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
		arg := args.Get(1).(*GHQueryForListFiles)
		// Populate Entries here as needed
		arg.Repository.Object.Tree.Entries = append(arg.Repository.Object.Tree.Entries, entry1, entry2)
	}).Return(nil)

	// Call the method to get file paths for repositories
	files, err := client.GetFilePathsForRepositories()

	// Verify the results
	if err != nil {
		t.Errorf("Error occurred: %v", err)
	}

	// duplicated files because of numnber of repositories for each entry
	expectedFiles := []string{
		"path/to/files/file1.txt",
		"path/to/files/file2.txt",
		"path/to/files/file1.txt",
		"path/to/files/file2.txt",
	}

	for _, expectedFile := range expectedFiles {
		if !contains(files, expectedFile) {
			t.Errorf("Expected file not found: %s", expectedFile)
		}
	}
}

func TestGitHubClient_GetChangedFilePathsSince(t *testing.T) {
	tests := []struct {
		name   string
		config GitHubConfig
		hour   int
		want   Paths
	}{
		{
			name: "Check for changed file paths since 1 hour ago",
			config: GitHubConfig{
				Owner:         "testowner",
				Repositories:  []string{"repo1", "repo2"},
				DefaultBranch: "main",
				Filter: GitHubFilter{
					FilePath:  "path/to/files",
					FileTypes: []string{".txt"},
				},
			},
			hour: 1,
			want: Paths{
				Added:    []string{"path/to/files/file1.txt", "path/to/files/file1.txt"},
				Removed:  []string{},
				Modified: []string{"path/to/files/file2.txt", "path/to/files/file2.txt"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ghClient := new(GHClientMock)
			ghClient.On("ListCommits", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return([]*github.RepositoryCommit{{
				SHA: github.String("1234567890"),
			}}, nil, nil)
			ghClient.On("GetCommit", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(&github.RepositoryCommit{Files: []*github.CommitFile{
				{
					Filename: github.String("path/to/files/file1.txt"),
					Status:   github.String("added"),
				},
				{
					Filename: github.String("path/to/files/file2.txt"),
					Status:   github.String("modified"),
				},
			}}, nil, nil)

			client := NewGitHubClient(ghClient, tt.config)
			paths, err := client.GetChangedFilePathsSince(tt.hour)

			if err != nil {
				t.Errorf("Error occurred: %v", err)
			}

			if !comparePaths(paths, tt.want) {
				t.Errorf("Expected paths do not match the result: %v", paths)
			}
		})
	}
}

// Helper function to check if a string is in a slice
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if s == str {
			return true
		}
	}
	return false
}

// Helper function to compare Paths
func comparePaths(paths1, paths2 Paths) bool {
	return compareStringSlices(paths1.Added, paths2.Added) &&
		compareStringSlices(paths1.Removed, paths2.Removed) &&
		compareStringSlices(paths1.Modified, paths2.Modified)
}

// Helper function to compare string slices
func compareStringSlices(slice1, slice2 []string) bool {
	if len(slice1) != len(slice2) {
		return false
	}
	for i := range slice1 {
		if slice1[i] != slice2[i] {
			return false
		}
	}
	return true
}
